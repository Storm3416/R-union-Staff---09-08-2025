const data = {
    staffServeur: [
        "Charlie Rivers",
        "Lucas DeLaCroisseeDesPommes",
    ],
    presents: [
        { name: "Athena Heartfillia", role: "Mod√©ratrice loyale" },
        { name: "Charlie Rivers", role: "Mod√©rateur" },
        { name: "James Snow", role: "Mod√©rateur s√©nior" },
        { name: "Jean Pierrot-Oryanov", role: "Mod√©rateur certifi√©" },
        { name: "Lucas DeLaCroisseeDesPommes", role: "Mod√©rateur" },
        { name: "Mickey Venderbrouk", role: "Mod√©rateur" },
        { name: "Peter Middley", role: "Mod√©rateur certifi√©" },
        { name: "Samuel Dimitrov", role: "Mod√©rateur apprenti" },
        { name: "Storm Kappa", role: "Mod√©rateur apprenti" },
        { name: "Bryan Garcias", role: "Administrateur" },
        { name: "Enzo Woo", role: "Responsable serveurs" },
        { name: "Lune Nemmour", role: "Administratrice" },
        { name: "Julien Castello", role: "Administrateur" },
        { name: "Kobralost", role: "Fondateur" },
    ],
    late: [
        { name: "Nayo EME", delay: "~26 min" },
        { name: "Jordan Milano-Oryanov", delay: "~45 min" },
    ],
    rappels: [
        "Quand on est en mode admin, se mettre en vocal staff (sauf en live moderation).",
        "On √©vite les d√©bordements sur le Discord.",
        "On est une √©quipe, on doit s'entraider, pas s'enfoncer.",
        "Sur le dashboard, on doit mettre au moins un message pour indiquer ce qu'on fait, afin que personne ne soit d√©muni si vous avez pris sa demande et que vous ne lui dites rien.",
        "Essayez de consulter le dashboard plus r√©guli√®rement.",
        "Quand on part en vacances, informez votre r√©f√©rent des demandes en cours.",
        "Lors d'une plainte admin, notre devoir est de donner tous les √©l√©ments au joueur qui ont motiv√© notre r√©flexion et notre sanction.",
        "Quand on met une sanction, on v√©rifie le casier du joueur, on regarde bien que c'est le bon joueur √† sanctionner (regarder le nom en haut √† gauche), et on √©crit la sanction avec le plus d'informations possible pour bien la comprendre en cas de plainte ult√©rieure.",
        "Quand on met des sanctions, il est hors de question que cela repose sur une interpr√©tation personnelle ou des suppositions. Si aucune preuve tangible, on ne sanctionne pas (sauf si c'est flagrant : emote + coll√© √† un mur √† r√©p√©tition).",
        "Quand on est joueur et qu'on prend une sanction, on pr√©vient son r√©f√©rent, ne pas le cacher, car d√®s qu'il le voit, il peut vous taper sur les doigts.",
        "Quand on est en mode admin, on ne doit pas rester en mode fly et rester AFK s'il y a des tickets, et on ne reste pas AFK en cas d'urgence, on prend sa FDS.",
        "S'il y a √©norm√©ment de tickets (15, 20), il ne faut pas tous les traiter rapidement. Prenez votre temps pour les traiter convenablement afin que ce soit efficace et non b√¢cl√©.",
        "Sanction : L'orthographe doit √™tre correctement corrig√©e. Utilisez des outils comme https://www.reverso.net/orthographe/correcteur-francais/ pour √©viter les fautes, etc. D√©sormais, cela va impacter lourdement les bilans.",
        "Dans les MP, faites des phrases compl√®tes, car ils n'ont pas envie de deviner le sens de vos propos.",
        "Si on ne sait pas r√©pondre √† une question, on demande sur Discord aux autres membres du staff ou on envoie un message priv√©. (S'il n'y a pas de staff connect√©, dire au joueur qu'on ne sait pas et lui demander de refaire une demande demain ou sur le dashboard quand il y aura plus de mod√©rateurs connect√©s.)",
        "## Si pr√©sent dans la r√©union, on ne doit pas refaire ce qui a √©t√© dit dans la r√©union, car on est cens√© √™tre au courant."
    ],
    info: [
        "Mise en place de mesures plus importantes pour les personnes qui trollent (ban d‚Äôun an et timeout d‚Äôun an).",
        "Possibilit√© d'appliquer des sanctions plus s√©v√®res et plus r√©guli√®rement pour ceux qui jouent avec les limites.",
        "Ajout Formation : Mod√©rateur (Loyal, S√©nior, Certifi√©) vous pourrez essayer de vous engager en tant que formateur (cela peut prendre du temps, car il faut vous former vous-m√™me avant de former les autres).",
        "Ajout d'une p√©riode de formation ¬´ mod√©rateur en formation ¬ª (dur√©e : 1 √† 2 semaines) pour les nouveaux mod√©rateurs.",
        "Les mod√©rateurs en formation peuvent mod√©rer uniquement 1 heure par jour, accompagn√©s d'un formateur ou administrateur, pendant une p√©riode de 7 jours.",
    ],
    freeTopics: [
        "Jean Pierrot-Oryanov : a dit que Kobralost allait nous taper sur les doigts.",
        "Athena Heartfillia : est-ce que c'est possible pour les m√©tiers qui ne sont pas autoris√©s √† faire des actions ill√©gales (Keypad Crack, Lockpick) ?",
        "Kobralost : Peut-√™tre une commande !unstuck pour les joueurs qui sont bloqu√©s.",
        "Lucas DeLaCroisseeDesPommes : est-ce qu'au niveau des logs la mise √† jour avance ? R√©ponse de Bryan Garcias : oui, on y travaille.",
        "Lucas DeLaCroisseeDesPommes : pour le Kobralost Roleplay pour le serveur German, qu'en est-il ? R√©ponse de Kobralost : suite au fait qu'on a vir√© Marius, √ßa a chang√© un petit peu les plans, mais rien de grave.",
    ],
    rules: {
        additions: [
            "Rien √† dire pour l'instant.",
        ],
        edits: [
            "Rien √† dire pour l'instant.",
        ],
        removals: [
            "Rien √† dire pour l'instant.",
        ]
    },
    questions: [
        {
            q: "Lucas DeLaCroisseeDesPommes : si on conna√Æt une personne facilement √† contacter, est-ce qu'on peut lui communiquer la sanction ? (exemple : Discord)",
            a: [
                "R√©ponse de Kobralost : tu peux lui dire en lui faisant un ping, mais tu devras le faire pour tout le monde, pas que pour tes amis ou autres.",
            ]
        },
        {
            q: "Lucas DeLaCroisseeDesPommes : est-ce qu'on peut avoir des r√©unions en priv√© avec nos r√©f√©rents ?",
            a: [
                "R√©ponse de Bryan Garcias : oui, √ßa s'est d√©j√† produit et √ßa d√©pend du r√©f√©rent.",
                "R√©ponse de Kobralost : on pourrait mettre en place des r√©unions priv√©es avec les r√©f√©rents.",
            ]
        },
        {
            q: "Jean Pierrot-Oryanov : quand est-ce que les formations vont commencer ?",
            a: [
                "R√©ponse de Kobralost : √† partir de maintenant, il faut juste demander √† un administrateur pour pr√©venir et vous pourrez √™tre pr√©sents dans la r√©union.",
            ]
        },
        {
            q: "Charlie Rivers : est-ce qu'on a pens√© au risque potentiel de fuite du mod√©rateur ?",
            a: [
                "R√©ponse de Bryan Garcias : il n'y a pas plus d'informations que lors de la live moderation.",
            ]
        }
    ],
    audio: {
        filename: "(Audio) 2025-08-09 21-03-35.m4a"
    }
};


const $ = (sel, p = document) => p.querySelector(sel);
const $$ = (sel, p = document) => Array.from(p.querySelectorAll(sel));

function render() {
    const chipsStaff = document.getElementById('chips-staff');
    if (chipsStaff) { chipsStaff.innerHTML = data.staffServeur.map(n => `<li>${escapeHtml(n)}</li>`).join(''); }

    const grid = $('#grid-presents');
    grid.innerHTML = data.presents.map(p => personCard(p)).join('');

    const chipsLate = document.getElementById('chips-late');
    if (chipsLate) { chipsLate.innerHTML = data.late.map(l => `<li><strong>${escapeHtml(l.name)}</strong> <span class="muted">(${escapeHtml(l.delay)})</span></li>`).join(''); }

    const rap = $('#list-rappels');
    rap.innerHTML = data.rappels.map((r, i) => {
        const trimmed = r.trimStart();
        const hasMarker = trimmed.startsWith('##');
        const display = hasMarker ? trimmed.replace(/^##\s*/, '') : r;
        const isImportant = hasMarker;
        const content = isImportant
            ? `<strong>${linkify(display)}</strong> <span class="badge important" title="Important">Important</span>`
            : linkify(display);
        return `<li data-index="${i}"${isImportant ? ' class="important"' : ''}>${content}</li>`;
    }).join('');

    const infoBox = document.getElementById('info-content');
    if (Array.isArray(data.info)) {
        infoBox.innerHTML = '<ul class="list">' + data.info.map(item => `<li>${linkify(item)}</li>`).join('') + '</ul>';
    } else {
        infoBox.innerHTML = `<p>${linkify(data.info)}</p>`;
    }

    // Free topics (Sujets libres)
    const free = document.getElementById('free-topics');
    if (free) {
        const topics = Array.isArray(data.freeTopics) ? data.freeTopics : [];
        if (topics.length) {
            const items = topics.map(t => {
                if (t && typeof t === 'object') {
                    const title = escapeHtml(t.title ?? 'Sujet');
                    const details = t.details ? `<div class="muted small">${linkify(t.details)}</div>` : '';
                    return `<li><div><strong>${title}</strong>${details}</div></li>`;
                }
                return `<li>${linkify(String(t))}</li>`;
            }).join('');
            free.innerHTML = `<ul class="list">${items}</ul>`;
        } else {
            free.innerHTML = '<p class="muted">Aucun sujet libre pour le moment.</p>';
        }
    }

    const rulesAdd = document.getElementById('rules-additions');
    const rulesEd = document.getElementById('rules-edits');
    const rulesRem = document.getElementById('rules-removals');
    if (rulesAdd && rulesRem) {
        rulesAdd.innerHTML = (data.rules?.additions ?? []).map(r => `<li>${linkify(r)}</li>`).join('') || '<li class="muted">Aucun ajout</li>';
        if (rulesEd) {
            rulesEd.innerHTML = (data.rules?.edits ?? []).map(r => `<li>${linkify(r)}</li>`).join('') || '<li class="muted">Aucune √©dition</li>';
        }
        rulesRem.innerHTML = (data.rules?.removals ?? []).map(r => `<li>${linkify(r)}</li>`).join('') || '<li class="muted">Aucune suppression</li>';
    }

    const qa = $('#qa-list');
    qa.innerHTML = data.questions.map(item => {
        const answers = Array.isArray(item.a) ? item.a : [item.a];
        const answersHtml = answers.map(a => `<li>${linkify(a)}</li>`).join('');
        return `
        <div class="item">
            <div class="q">Q: ${linkify(item.q)}</div>
            <div class="a"><span class="label">A:</span>
                <ul class="answers">${answersHtml}</ul>
            </div>
        </div>`;
    }).join('');

    const audioEl = $('#meetingAudio');
    audioEl.src = encodeURI(data.audio.filename);
    $('#audio-filename').textContent = data.audio.filename;
    setupPlayer(audioEl);

    $('#year').textContent = String(new Date().getFullYear());

    const stats = document.getElementById('stats');
    if (stats) {
        const total = data.presents.length;
        const admins = data.presents.filter(p => /admin/i.test(p.role)).length;
        const certifies = data.presents.filter(p => /certifi√©/i.test(p.role)).length;
        const apprentis = data.presents.filter(p => /apprenti/i.test(p.role)).length;
        stats.innerHTML = `
      <div class="stat"><div class="n">${total}</div><div class="t">Pr√©sents</div></div>
      <div class="stat"><div class="n">${admins}</div><div class="t">Admin</div></div>
      <div class="stat"><div class="n">${certifies}</div><div class="t">Certifi√©s</div></div>
      <div class="stat"><div class="n">${apprentis}</div><div class="t">Apprentis</div></div>
    `;
    }
}

function personCard(p) {
    return `
  <article class="person" data-name="${escapeAttr(p.name)}" data-role="${escapeAttr(p.role)}">
    <h3>${escapeHtml(p.name)}</h3>
    <div class="role">${escapeHtml(p.role)}</div>
    ${p.left ? '<span class="badge red" title="A quitt√© le staff">parti</span>' : ''}
  </article>`;
}

function escapeHtml(s) {
    return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
}
function escapeAttr(s) {
    return escapeHtml(s).replaceAll('"', '&quot;');
}

function linkify(text) {
    const str = String(text ?? '');
    const urlRe = /(https?:\/\/[^\s<>\"]+)(?=[\s'"\)<>]|$)/g;
    let out = '';
    let last = 0;
    for (const m of str.matchAll(urlRe)) {
        const idx = m.index ?? 0;
        const url = m[1];
        out += escapeHtml(str.slice(last, idx));
        const safeUrl = escapeAttr(url);
        out += `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${escapeHtml(url)}</a>`;
        last = idx + url.length;
    }
    out += escapeHtml(str.slice(last));
    return out;
}

function setupTheme() {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const saved = localStorage.getItem('theme');
    if (saved === 'light') root.classList.add('light');
    btn.addEventListener('click', () => {
        root.classList.toggle('light');
        localStorage.setItem('theme', root.classList.contains('light') ? 'light' : 'dark');
        btn.textContent = root.classList.contains('light') ? 'üåû' : 'üåô';
    });
    btn.textContent = root.classList.contains('light') ? 'üåû' : 'üåô';
}

function setupSearch() {
    const input = document.getElementById('peopleSearch');
    window.addEventListener('keydown', (e) => {
        if (e.key === '/' && document.activeElement !== input) {
            e.preventDefault(); input.focus(); input.select();
        }
    });
    input.addEventListener('input', () => {
        const q = input.value.trim().toLowerCase();
        filterPeople(q);
    });
}

function filterPeople(q) {
    const cards = $$('.person');
    if (!q) { cards.forEach(c => c.style.display = ''); return; }
    cards.forEach(card => {
        const name = card.dataset.name.toLowerCase();
        const role = card.dataset.role.toLowerCase();
        card.style.display = (name.includes(q) || role.includes(q)) ? '' : 'none';
    });
}

function setupRappelsToggle() {
    const btn = document.getElementById('btnToggleRappels');
    const list = document.getElementById('list-rappels');
    let hidden = false;
    btn.addEventListener('click', () => {
        hidden = !hidden;
        list.style.display = hidden ? 'none' : '';
    });
}

function setupCopyAudioLink() {
    const btn = document.getElementById('btnCopyLink');
    const audio = document.getElementById('meetingAudio');
    btn.addEventListener('click', async () => {
        try {
            const url = location.origin === 'null' || location.origin === '' ? data.audio.filename : new URL(audio.src, location.href).href;
            await navigator.clipboard.writeText(url);
            btn.textContent = 'Copi√© ‚úì';
            setTimeout(() => btn.textContent = 'Copier le lien', 1500);
        } catch (err) {
            btn.textContent = '√âchec copie';
            setTimeout(() => btn.textContent = 'Copier le lien', 1500);
        }
    });
}

window.addEventListener('DOMContentLoaded', () => {
    render();
    setupTheme();
    setupSearch();
    setupRappelsToggle();
    setupCopyAudioLink();
});

function fmtTime(sec) {
    if (!isFinite(sec) || sec < 0) return '0:00';
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60).toString().padStart(2, '0');
    return `${m}:${s}`;
}

function setupPlayer(audio) {
    const player = document.getElementById('player');
    const btnPlay = document.getElementById('btnPlayPause');
    const btnBack = document.getElementById('btnBack10');
    const btnFwd = document.getElementById('btnFwd10');
    const cur = document.getElementById('currentTime');
    const dur = document.getElementById('duration');
    const bar = document.getElementById('progressBar');
    const played = document.getElementById('playedBar');
    const buffered = document.getElementById('bufferedBar');
    const volume = document.getElementById('volume');
    const rate = document.getElementById('playbackRate');

    volume.value = String(audio.volume);
    rate.value = '1';

    function updateProgress() {
        const p = audio.duration ? (audio.currentTime / audio.duration) * 100 : 0;
        played.style.width = `${p}%`;
        cur.textContent = fmtTime(audio.currentTime);
        dur.textContent = fmtTime(audio.duration);
        bar.setAttribute('aria-valuenow', String(Math.round(p)));
    }

    function updateBuffered() {
        try {
            if (audio.buffered.length) {
                const end = audio.buffered.end(audio.buffered.length - 1);
                const p = audio.duration ? (end / audio.duration) * 100 : 0;
                buffered.style.width = `${p}%`;
            }
        } catch { }
    }

    function toggle() {
        if (audio.paused) { audio.play(); }
        else { audio.pause(); }
    }

    btnPlay.addEventListener('click', toggle);
    btnBack.addEventListener('click', () => { audio.currentTime = Math.max(0, audio.currentTime - 10); });
    btnFwd.addEventListener('click', () => { audio.currentTime = Math.min(audio.duration || Infinity, audio.currentTime + 10); });

    audio.addEventListener('play', () => { btnPlay.textContent = '‚è∏'; player.classList.add('playing'); });
    audio.addEventListener('pause', () => { btnPlay.textContent = '‚ñ∂'; player.classList.remove('playing'); });
    audio.addEventListener('timeupdate', updateProgress);
    audio.addEventListener('durationchange', updateProgress);
    audio.addEventListener('progress', updateBuffered);
    audio.addEventListener('loadedmetadata', () => { updateProgress(); updateBuffered(); });

    function seekFromClientX(clientX) {
        const rect = bar.getBoundingClientRect();
        const ratio = Math.min(1, Math.max(0, (clientX - rect.left) / rect.width));
        if (isFinite(audio.duration)) audio.currentTime = ratio * audio.duration;
    }
    bar.addEventListener('click', (e) => seekFromClientX(e.clientX));
    let dragging = false;
    bar.addEventListener('pointerdown', (e) => { dragging = true; bar.setPointerCapture(e.pointerId); seekFromClientX(e.clientX); });
    bar.addEventListener('pointermove', (e) => { if (dragging) seekFromClientX(e.clientX); });
    bar.addEventListener('pointerup', (e) => { dragging = false; bar.releasePointerCapture(e.pointerId); });
    bar.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') { audio.currentTime = Math.max(0, audio.currentTime - 5); e.preventDefault(); }
        if (e.key === 'ArrowRight') { audio.currentTime = Math.min(audio.duration || Infinity, audio.currentTime + 5); e.preventDefault(); }
        if (e.key === 'Home') { audio.currentTime = 0; e.preventDefault(); }
        if (e.key === 'End' && isFinite(audio.duration)) { audio.currentTime = audio.duration; e.preventDefault(); }
    });

    volume.addEventListener('input', () => { audio.volume = Number(volume.value); });
    rate.addEventListener('change', () => { audio.playbackRate = Number(rate.value); });
}

