const data = {
    staffServeur: [
        "Charlie Rivers",
        "Lucas DeLaCroisseeDesPommes",
    ],
    presents: [
        { name: "Athena Heartfillia", role: "Modératrice loyale" },
        { name: "Charlie Rivers", role: "Modérateur" },
        { name: "James Snow", role: "Modérateur sénior" },
        { name: "Jean Pierrot-Oryanov", role: "Modérateur certifié" },
        { name: "Lucas DeLaCroisseeDesPommes", role: "Modérateur" },
        { name: "Mickey Venderbrouk", role: "Modérateur" },
        { name: "Peter Middley", role: "Modérateur certifié" },
        { name: "Samuel Dimitrov", role: "Modérateur apprenti" },
        { name: "Storm Kappa", role: "Modérateur apprenti" },
        { name: "Bryan Garcias", role: "Administrateur" },
        { name: "Enzo Woo", role: "Responsable serveurs" },
        { name: "Lune Nemmour", role: "Administratrice" },
        { name: "Julien Castello", role: "Administrateur" },
        { name: "Kobralost", role: "Fondateur" },
    ],
    late: [
        { name: "Nayo EME", delay: "~26 min" },
        { name: "Jordan Milano-Oryanov", delay: "~45 min" },
    ],
    rappels: [
        "Quand on est en mode admin, se mettre en vocal staff (sauf en live moderation).",
        "On évite les débordements sur le Discord.",
        "On est une équipe, on doit s'entraider, pas s'enfoncer.",
        "Sur le dashboard, on doit mettre au moins un message pour indiquer ce qu'on fait, afin que personne ne soit démuni si vous avez pris sa demande et que vous ne lui dites rien.",
        "Essayez de consulter le dashboard plus régulièrement.",
        "Quand on part en vacances, informez votre référent des demandes en cours.",
        "Lors d'une plainte admin, notre devoir est de donner tous les éléments au joueur qui ont motivé notre réflexion et notre sanction.",
        "Quand on met une sanction, on vérifie le casier du joueur, on regarde bien que c'est le bon joueur à sanctionner (regarder le nom en haut à gauche), et on écrit la sanction avec le plus d'informations possible pour bien la comprendre en cas de plainte ultérieure.",
        "Quand on met des sanctions, il est hors de question que cela repose sur une interprétation personnelle ou des suppositions. Si aucune preuve tangible, on ne sanctionne pas (sauf si c'est flagrant : emote + collé à un mur à répétition).",
        "Quand on est joueur et qu'on prend une sanction, on prévient son référent, ne pas le cacher, car dès qu'il le voit, il peut vous taper sur les doigts.",
        "Quand on est en mode admin, on ne doit pas rester en mode fly et rester AFK s'il y a des tickets, et on ne reste pas AFK en cas d'urgence, on prend sa FDS.",
        "S'il y a énormément de tickets (15, 20), il ne faut pas tous les traiter rapidement. Prenez votre temps pour les traiter convenablement afin que ce soit efficace et non bâclé.",
        "Sanction : L'orthographe doit être correctement corrigée. Utilisez des outils comme https://www.reverso.net/orthographe/correcteur-francais/ pour éviter les fautes, etc. Désormais, cela va impacter lourdement les bilans.",
        "Dans les MP, faites des phrases complètes, car ils n'ont pas envie de deviner le sens de vos propos.",
        "Si on ne sait pas répondre à une question, on demande sur Discord aux autres membres du staff ou on envoie un message privé. (S'il n'y a pas de staff connecté, dire au joueur qu'on ne sait pas et lui demander de refaire une demande demain ou sur le dashboard quand il y aura plus de modérateurs connectés.)",
        "## Si présent dans la réunion, on ne doit pas refaire ce qui a été dit dans la réunion, car on est censé être au courant."
    ],
    info: [
        "Mise en place de mesures plus importantes pour les personnes qui trollent (ban d’un an et timeout d’un an).",
        "Possibilité d'appliquer des sanctions plus sévères et plus régulièrement pour ceux qui jouent avec les limites.",
        "Ajout Formation : Modérateur (Loyal, Sénior, Certifié) vous pourrez essayer de vous engager en tant que formateur (cela peut prendre du temps, car il faut vous former vous-même avant de former les autres).",
        "Ajout d'une période de formation « modérateur en formation » (durée : 1 à 2 semaines) pour les nouveaux modérateurs.",
        "Les modérateurs en formation peuvent modérer uniquement 1 heure par jour, accompagnés d'un formateur ou administrateur, pendant une période de 7 jours.",
    ],
    freeTopics: [
        "Jean Pierrot-Oryanov : a dit que Kobralost allait nous taper sur les doigts.",
        "Athena Heartfillia : est-ce que c'est possible pour les métiers qui ne sont pas autorisés à faire des actions illégales (Keypad Crack, Lockpick) ?",
        "Kobralost : Peut-être une commande !unstuck pour les joueurs qui sont bloqués.",
        "Lucas DeLaCroisseeDesPommes : est-ce qu'au niveau des logs la mise à jour avance ? Réponse de Bryan Garcias : oui, on y travaille.",
        "Lucas DeLaCroisseeDesPommes : pour le Kobralost Roleplay pour le serveur German, qu'en est-il ? Réponse de Kobralost : suite au fait qu'on a viré Marius, ça a changé un petit peu les plans, mais rien de grave.",
    ],
    rules: {
        additions: [
            "Rien à dire pour l'instant.",
        ],
        edits: [
            "Rien à dire pour l'instant.",
        ],
        removals: [
            "Rien à dire pour l'instant.",
        ]
    },
    questions: [
        {
            q: "Lucas DeLaCroisseeDesPommes : si on connaît une personne facilement à contacter, est-ce qu'on peut lui communiquer la sanction ? (exemple : Discord)",
            a: [
                "Réponse de Kobralost : tu peux lui dire en lui faisant un ping, mais tu devras le faire pour tout le monde, pas que pour tes amis ou autres.",
            ]
        },
        {
            q: "Lucas DeLaCroisseeDesPommes : est-ce qu'on peut avoir des réunions en privé avec nos référents ?",
            a: [
                "Réponse de Bryan Garcias : oui, ça s'est déjà produit et ça dépend du référent.",
                "Réponse de Kobralost : on pourrait mettre en place des réunions privées avec les référents.",
            ]
        },
        {
            q: "Jean Pierrot-Oryanov : quand est-ce que les formations vont commencer ?",
            a: [
                "Réponse de Kobralost : à partir de maintenant, il faut juste demander à un administrateur pour prévenir et vous pourrez être présents dans la réunion.",
            ]
        },
        {
            q: "Charlie Rivers : est-ce qu'on a pensé au risque potentiel de fuite du modérateur ?",
            a: [
                "Réponse de Bryan Garcias : il n'y a pas plus d'informations que lors de la live moderation.",
            ]
        }
    ],
    audio: {
        filename: "(Audio) 2025-08-09 21-03-35.m4a"
    }
};


const $ = (sel, p = document) => p.querySelector(sel);
const $$ = (sel, p = document) => Array.from(p.querySelectorAll(sel));

function render() {
    const chipsStaff = document.getElementById('chips-staff');
    if (chipsStaff) { chipsStaff.innerHTML = data.staffServeur.map(n => `<li>${escapeHtml(n)}</li>`).join(''); }

    const grid = $('#grid-presents');
    grid.innerHTML = data.presents.map(p => personCard(p)).join('');

    const chipsLate = document.getElementById('chips-late');
    if (chipsLate) { chipsLate.innerHTML = data.late.map(l => `<li><strong>${escapeHtml(l.name)}</strong> <span class="muted">(${escapeHtml(l.delay)})</span></li>`).join(''); }

    const rap = $('#list-rappels');
    rap.innerHTML = data.rappels.map((r, i) => {
        const trimmed = r.trimStart();
        const hasMarker = trimmed.startsWith('##');
        const display = hasMarker ? trimmed.replace(/^##\s*/, '') : r;
        const isImportant = hasMarker;
        const content = isImportant
            ? `<strong>${linkify(display)}</strong> <span class="badge important" title="Important">Important</span>`
            : linkify(display);
        return `<li data-index="${i}"${isImportant ? ' class="important"' : ''}>${content}</li>`;
    }).join('');

    const infoBox = document.getElementById('info-content');
    if (Array.isArray(data.info)) {
        infoBox.innerHTML = '<ul class="list">' + data.info.map(item => `<li>${linkify(item)}</li>`).join('') + '</ul>';
    } else {
        infoBox.innerHTML = `<p>${linkify(data.info)}</p>`;
    }

    // Free topics (Sujets libres)
    const free = document.getElementById('free-topics');
    if (free) {
        const topics = Array.isArray(data.freeTopics) ? data.freeTopics : [];
        if (topics.length) {
            const items = topics.map(t => {
                if (t && typeof t === 'object') {
                    const title = escapeHtml(t.title ?? 'Sujet');
                    const details = t.details ? `<div class="muted small">${linkify(t.details)}</div>` : '';
                    return `<li><div><strong>${title}</strong>${details}</div></li>`;
                }
                return `<li>${linkify(String(t))}</li>`;
            }).join('');
            free.innerHTML = `<ul class="list">${items}</ul>`;
        } else {
            free.innerHTML = '<p class="muted">Aucun sujet libre pour le moment.</p>';
        }
    }

    const rulesAdd = document.getElementById('rules-additions');
    const rulesEd = document.getElementById('rules-edits');
    const rulesRem = document.getElementById('rules-removals');
    if (rulesAdd && rulesRem) {
        rulesAdd.innerHTML = (data.rules?.additions ?? []).map(r => `<li>${linkify(r)}</li>`).join('') || '<li class="muted">Aucun ajout</li>';
        if (rulesEd) {
            rulesEd.innerHTML = (data.rules?.edits ?? []).map(r => `<li>${linkify(r)}</li>`).join('') || '<li class="muted">Aucune édition</li>';
        }
        rulesRem.innerHTML = (data.rules?.removals ?? []).map(r => `<li>${linkify(r)}</li>`).join('') || '<li class="muted">Aucune suppression</li>';
    }

    const qa = $('#qa-list');
    qa.innerHTML = data.questions.map(item => {
        const answers = Array.isArray(item.a) ? item.a : [item.a];
        const answersHtml = answers.map(a => `<li>${linkify(a)}</li>`).join('');
        return `
        <div class="item">
            <div class="q">Q: ${linkify(item.q)}</div>
            <div class="a"><span class="label">A:</span>
                <ul class="answers">${answersHtml}</ul>
            </div>
        </div>`;
    }).join('');

    const audioEl = $('#meetingAudio');
    audioEl.src = encodeURI(data.audio.filename);
    $('#audio-filename').textContent = data.audio.filename;
    setupPlayer(audioEl);

    $('#year').textContent = String(new Date().getFullYear());

    const stats = document.getElementById('stats');
    if (stats) {
        const total = data.presents.length;
        const admins = data.presents.filter(p => /admin/i.test(p.role)).length;
        const certifies = data.presents.filter(p => /certifié/i.test(p.role)).length;
        const apprentis = data.presents.filter(p => /apprenti/i.test(p.role)).length;
        stats.innerHTML = `
      <div class="stat"><div class="n">${total}</div><div class="t">Présents</div></div>
      <div class="stat"><div class="n">${admins}</div><div class="t">Admin</div></div>
      <div class="stat"><div class="n">${certifies}</div><div class="t">Certifiés</div></div>
      <div class="stat"><div class="n">${apprentis}</div><div class="t">Apprentis</div></div>
    `;
    }
}

function personCard(p) {
    return `
  <article class="person" data-name="${escapeAttr(p.name)}" data-role="${escapeAttr(p.role)}">
    <h3>${escapeHtml(p.name)}</h3>
    <div class="role">${escapeHtml(p.role)}</div>
    ${p.left ? '<span class="badge red" title="A quitté le staff">parti</span>' : ''}
  </article>`;
}

function escapeHtml(s) {
    return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
}
function escapeAttr(s) {
    return escapeHtml(s).replaceAll('"', '&quot;');
}

function linkify(text) {
    const str = String(text ?? '');
    const urlRe = /(https?:\/\/[^\s<>\"]+)(?=[\s'"\)<>]|$)/g;
    let out = '';
    let last = 0;
    for (const m of str.matchAll(urlRe)) {
        const idx = m.index ?? 0;
        const url = m[1];
        out += escapeHtml(str.slice(last, idx));
        const safeUrl = escapeAttr(url);
        out += `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${escapeHtml(url)}</a>`;
        last = idx + url.length;
    }
    out += escapeHtml(str.slice(last));
    return out;
}

function setupTheme() {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const saved = localStorage.getItem('theme');
    if (saved === 'light') root.classList.add('light');
    btn.addEventListener('click', () => {
        root.classList.toggle('light');
        localStorage.setItem('theme', root.classList.contains('light') ? 'light' : 'dark');
        btn.textContent = root.classList.contains('light') ? '🌞' : '🌙';
    });
    btn.textContent = root.classList.contains('light') ? '🌞' : '🌙';
}

function setupSearch() {
    const input = document.getElementById('peopleSearch');
    window.addEventListener('keydown', (e) => {
        if (e.key === '/' && document.activeElement !== input) {
            e.preventDefault(); input.focus(); input.select();
        }
    });
    input.addEventListener('input', () => {
        const q = input.value.trim().toLowerCase();
        filterPeople(q);
    });
}

function filterPeople(q) {
    const cards = $$('.person');
    if (!q) { cards.forEach(c => c.style.display = ''); return; }
    cards.forEach(card => {
        const name = card.dataset.name.toLowerCase();
        const role = card.dataset.role.toLowerCase();
        card.style.display = (name.includes(q) || role.includes(q)) ? '' : 'none';
    });
}

function setupRappelsToggle() {
    const btn = document.getElementById('btnToggleRappels');
    const list = document.getElementById('list-rappels');
    let hidden = false;
    btn.addEventListener('click', () => {
        hidden = !hidden;
        list.style.display = hidden ? 'none' : '';
    });
}

function setupCopyAudioLink() {
    const btn = document.getElementById('btnCopyLink');
    const audio = document.getElementById('meetingAudio');
    btn.addEventListener('click', async () => {
        try {
            const url = location.origin === 'null' || location.origin === '' ? data.audio.filename : new URL(audio.src, location.href).href;
            await navigator.clipboard.writeText(url);
            btn.textContent = 'Copié ✓';
            setTimeout(() => btn.textContent = 'Copier le lien', 1500);
        } catch (err) {
            btn.textContent = 'Échec copie';
            setTimeout(() => btn.textContent = 'Copier le lien', 1500);
        }
    });
}

window.addEventListener('DOMContentLoaded', () => {
    render();
    setupTheme();
    setupSearch();
    setupRappelsToggle();
    setupCopyAudioLink();
});

function fmtTime(sec) {
    if (!isFinite(sec) || sec < 0) return '0:00';
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60).toString().padStart(2, '0');
    return `${m}:${s}`;
}

function setupPlayer(audio) {
    const player = document.getElementById('player');
    const btnPlay = document.getElementById('btnPlayPause');
    const btnBack = document.getElementById('btnBack10');
    const btnFwd = document.getElementById('btnFwd10');
    const cur = document.getElementById('currentTime');
    const dur = document.getElementById('duration');
    const bar = document.getElementById('progressBar');
    const played = document.getElementById('playedBar');
    const buffered = document.getElementById('bufferedBar');
    const volume = document.getElementById('volume');
    const rate = document.getElementById('playbackRate');

    volume.value = String(audio.volume);
    rate.value = '1';

    function updateProgress() {
        const p = audio.duration ? (audio.currentTime / audio.duration) * 100 : 0;
        played.style.width = `${p}%`;
        cur.textContent = fmtTime(audio.currentTime);
        dur.textContent = fmtTime(audio.duration);
        bar.setAttribute('aria-valuenow', String(Math.round(p)));
    }

    function updateBuffered() {
        try {
            if (audio.buffered.length) {
                const end = audio.buffered.end(audio.buffered.length - 1);
                const p = audio.duration ? (end / audio.duration) * 100 : 0;
                buffered.style.width = `${p}%`;
            }
        } catch { }
    }

    function toggle() {
        if (audio.paused) { audio.play(); }
        else { audio.pause(); }
    }

    btnPlay.addEventListener('click', toggle);
    btnBack.addEventListener('click', () => { audio.currentTime = Math.max(0, audio.currentTime - 10); });
    btnFwd.addEventListener('click', () => { audio.currentTime = Math.min(audio.duration || Infinity, audio.currentTime + 10); });

    audio.addEventListener('play', () => { btnPlay.textContent = '⏸'; player.classList.add('playing'); });
    audio.addEventListener('pause', () => { btnPlay.textContent = '▶'; player.classList.remove('playing'); });
    audio.addEventListener('timeupdate', updateProgress);
    audio.addEventListener('durationchange', updateProgress);
    audio.addEventListener('progress', updateBuffered);
    audio.addEventListener('loadedmetadata', () => { updateProgress(); updateBuffered(); });

    function seekFromClientX(clientX) {
        const rect = bar.getBoundingClientRect();
        const ratio = Math.min(1, Math.max(0, (clientX - rect.left) / rect.width));
        if (isFinite(audio.duration)) audio.currentTime = ratio * audio.duration;
    }
    bar.addEventListener('click', (e) => seekFromClientX(e.clientX));
    let dragging = false;
    bar.addEventListener('pointerdown', (e) => { dragging = true; bar.setPointerCapture(e.pointerId); seekFromClientX(e.clientX); });
    bar.addEventListener('pointermove', (e) => { if (dragging) seekFromClientX(e.clientX); });
    bar.addEventListener('pointerup', (e) => { dragging = false; bar.releasePointerCapture(e.pointerId); });
    bar.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') { audio.currentTime = Math.max(0, audio.currentTime - 5); e.preventDefault(); }
        if (e.key === 'ArrowRight') { audio.currentTime = Math.min(audio.duration || Infinity, audio.currentTime + 5); e.preventDefault(); }
        if (e.key === 'Home') { audio.currentTime = 0; e.preventDefault(); }
        if (e.key === 'End' && isFinite(audio.duration)) { audio.currentTime = audio.duration; e.preventDefault(); }
    });

    volume.addEventListener('input', () => { audio.volume = Number(volume.value); });
    rate.addEventListener('change', () => { audio.playbackRate = Number(rate.value); });
}

